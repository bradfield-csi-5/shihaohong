package main

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
)

const (
	SERVER_HOST = "8.8.8.8"
	SERVER_PORT = "53"
	SERVER_TYPE = "udp"
)

const (
	IPv4len             = 4
	DNSHeaderLength     = 12
	DNSQueryHeaderFlags = 0x0120 // Wireshark val, TODO: decompose it
	DNSMessageMaxLength = 512    // RFC 1035, 2.3.4
)

type DNSHeader struct {
	ID      uint16
	Flags   uint16
	QDCount uint16
	ANCount uint16
	NSCount uint16
	ARCount uint16
}

type DNSQuestion struct {
	QName  string
	QType  uint16
	QClass uint16
}

type ResourceRecord struct {
	Name     string
	TypeCode uint16
	Class    uint16
	TTL      uint32
	RDLength uint16
	RData    string
}

type DNSMessage struct {
	Header     DNSHeader
	Question   DNSQuestion
	Answer     ResourceRecord
	Authority  ResourceRecord
	Additional ResourceRecord
}

// A domain name represented as a sequence of labels, where
// each label consists of a length octet followed by that
// number of octets.  The domain name terminates with the
// zero length octet for the null label of the root.  Note
// that this field may be an odd number of octets; no
// padding is used.
func (msg *DNSMessage) encodeQName() []byte {
	var data = make([]byte, 0)

	// get qname labels
	labels := strings.Split(msg.Question.QName, ".")

	// encode length
	// encode each character as bytes
	for _, label := range labels {
		data = append(data, byte(len(label)))
		data = append(data, []byte(label)...)
	}

	// encode 0x00 to terminate
	data = append(data, byte(0))
	return data
}

func (msg *DNSMessage) encodeDNSQuery() []byte {
	var data = make([]byte, 0)
	fmt.Println(data)
	data = binary.BigEndian.AppendUint16(data, msg.Header.ID)
	data = binary.BigEndian.AppendUint16(data, msg.Header.Flags)
	data = binary.BigEndian.AppendUint16(data, msg.Header.QDCount)
	data = binary.BigEndian.AppendUint16(data, msg.Header.ANCount)
	data = binary.BigEndian.AppendUint16(data, msg.Header.NSCount)
	data = binary.BigEndian.AppendUint16(data, msg.Header.ARCount)
	data = append(data, msg.encodeQName()...)
	data = binary.BigEndian.AppendUint16(data, msg.Question.QType)
	data = binary.BigEndian.AppendUint16(data, msg.Question.QClass)
	return data
}

func main() {
	connection, err := net.Dial(SERVER_TYPE, SERVER_HOST+":"+SERVER_PORT)
	if err != nil {
		panic(err)
	}
	defer connection.Close()

	// hard-code for now
	msg := DNSMessage{
		Header: DNSHeader{
			ID:      uint16(0x614f), // TODO: is this randomly generated by program?
			Flags:   DNSQueryHeaderFlags,
			QDCount: 1,
			NSCount: 0,
			ANCount: 0,
			ARCount: 0,
		},
		Question: DNSQuestion{
			QName:  "www.wikipedia.org",
			QType:  1, // assume Type A only for now
			QClass: 1, // https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
		},
	}

	_, err = connection.Write(msg.encodeDNSQuery())
	if err != nil {
		panic(err)
	}

	buffer := make([]byte, DNSMessageMaxLength)
	mLen, err := connection.Read(buffer)
	if err != nil {
		panic(err)
	}

	// TODO: decode received message
	fmt.Println("Received: ", string(buffer[:mLen]))
}
