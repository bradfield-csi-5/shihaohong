package main

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
)

const (
	SERVER_HOST = "8.8.8.8"
	SERVER_PORT = "53"
	SERVER_TYPE = "udp"
)

const (
	IPv4len             = 4
	DNSHeaderLength     = 12
	DNSQueryHeaderFlags = 0x0120 // Wireshark val, TODO: decompose it
	DNSMessageMaxLength = 512    // RFC 1035, 2.3.4
)

type DNSHeader struct {
	ID      uint16
	Flags   uint16
	QDCount uint16
	ANCount uint16
	NSCount uint16
	ARCount uint16
}

type DNSQuestion struct {
	QName  string
	QType  uint16
	QClass uint16
}

type ResourceRecord struct {
	Name     string
	TypeCode uint16
	Class    uint16
	TTL      uint32
	RDLength uint16
	RData    string
}

type DNSMessage struct {
	Header     DNSHeader
	Question   DNSQuestion
	Answer     ResourceRecord
	Authority  ResourceRecord
	Additional ResourceRecord
}

// A domain name represented as a sequence of labels, where
// each label consists of a length octet followed by that
// number of octets.  The domain name terminates with the
// zero length octet for the null label of the root.  Note
// that this field may be an odd number of octets; no
// padding is used.
func (msg *DNSMessage) encodeQName() []byte {
	var data = make([]byte, 0)

	// get qname labels
	labels := strings.Split(msg.Question.QName, ".")

	// encode length
	// encode each character as bytes
	for _, label := range labels {
		data = append(data, byte(len(label)))
		data = append(data, []byte(label)...)
	}

	// encode 0x00 to terminate
	data = append(data, byte(0))
	return data
}

func (msg *DNSMessage) encodeDNSQuery() []byte {
	var data = make([]byte, 0)
	data = binary.BigEndian.AppendUint16(data, msg.Header.ID)
	data = binary.BigEndian.AppendUint16(data, msg.Header.Flags)
	data = binary.BigEndian.AppendUint16(data, msg.Header.QDCount)
	data = binary.BigEndian.AppendUint16(data, msg.Header.ANCount)
	data = binary.BigEndian.AppendUint16(data, msg.Header.NSCount)
	data = binary.BigEndian.AppendUint16(data, msg.Header.ARCount)
	data = append(data, msg.encodeQName()...)
	data = binary.BigEndian.AppendUint16(data, msg.Question.QType)
	data = binary.BigEndian.AppendUint16(data, msg.Question.QClass)
	return data
}

func decodeDNSMessage(b []byte) DNSMessage {
	qName, qNameLen := decodeQName(b[12:])
	qNameOffset := DNSHeaderLength + qNameLen
	return DNSMessage{
		Header: DNSHeader{
			ID:      binary.BigEndian.Uint16(b[0:2]),
			Flags:   binary.BigEndian.Uint16(b[2:4]),
			QDCount: binary.BigEndian.Uint16(b[4:6]),
			ANCount: binary.BigEndian.Uint16(b[6:8]),
			NSCount: binary.BigEndian.Uint16(b[8:10]),
			ARCount: binary.BigEndian.Uint16(b[10:12]),
		},
		Question: DNSQuestion{
			QName:  qName,
			QType:  binary.BigEndian.Uint16(b[qNameOffset : qNameOffset+2]),
			QClass: binary.BigEndian.Uint16(b[qNameOffset+2 : qNameOffset+4]),
		},
	}
}

// Assume b[0] is the start of QName
func decodeQName(b []byte) (qname string, len int) {
	qname = ""
	len = 0
	labelLen := b[len]
	for {
		len++
		for j := uint8(0); j < labelLen; j++ {
			qname += string(b[len])
			len++
		}

		labelLen = b[len]
		if labelLen == 0 {
			len++
			break
		} else {
			qname += "."
		}
	}
	return
}

func main() {
	connection, err := net.Dial(SERVER_TYPE, SERVER_HOST+":"+SERVER_PORT)
	if err != nil {
		panic(err)
	}
	defer connection.Close()

	// hard-code for now
	query := DNSMessage{
		Header: DNSHeader{
			ID:      uint16(0x614f), // TODO: is this randomly generated by program?
			Flags:   DNSQueryHeaderFlags,
			QDCount: 1,
			NSCount: 0,
			ANCount: 0,
			ARCount: 0,
		},
		Question: DNSQuestion{
			QName:  "www.wikipedia.org",
			QType:  1, // assume Type A only for now
			QClass: 1, // https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
		},
	}

	_, err = connection.Write(query.encodeDNSQuery())
	if err != nil {
		panic(err)
	}

	buffer := make([]byte, DNSMessageMaxLength)
	mLen, err := connection.Read(buffer)
	if err != nil {
		panic(err)
	}

	response := decodeDNSMessage(buffer[:mLen])
	fmt.Println("Sent: ", query)
	fmt.Println("Received: ", response)
}
